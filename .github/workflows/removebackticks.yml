---
name: Enterprise Codebase Integrity and Standardization Engine

on:
  push:
    branches: [ main, production, release/* ]
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Execute in dry-run mode (no commits)'
        required: false
        default: 'false'
        type: boolean
  schedule:
    - cron: '0 2 * * *' # Run daily at 2:00 AM UTC

jobs:
  standardize_codebase:
    name: Execute Global Code Standardization Protocol
    runs-on: ubuntu-latest
    env:
      DRY_RUN: ${{ github.event.inputs.dry_run == 'true' || false }}
      COMMIT_MESSAGE: "Automated Codebase Standardization: Removal of Markdown Code Block Delimiters"

    steps:
      - name: Initialize Repository Access and Configuration
        id: init
        run: |
          echo "--- Starting Enterprise Codebase Integrity Check ---"
          echo "Repository: ${{ github.repository }}"
          echo "Ref: ${{ github.ref }}"
          echo "Dry Run Mode Enabled: $DRY_RUN"
          
          # Set up Git user for potential commits
          git config --global user.name "Enterprise CI/CD Agent"
          git config --global user.email "ci-cd-agent@users.noreply.github.com"
          
          echo "Initialization complete."

      - name: Checkout Repository at Deep Revision Level
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Ensure full history access if needed for advanced checks

      - name: Comprehensive Code Structure Sanitization Module
        id: sanitization
        run: |
          echo "Executing deep scan for non-compliant markdown code block syntax..."
          
          # Use find for more robust file discovery, excluding common binary/system directories
          find . -type f -not -path "./.git/*" -print0 | while IFS= read -r -d $'\0' file; do
            
            # Preliminary check: Only process files that appear to be text-based (heuristic check)
            if ! git ls-files --error-unmatch "$file" > /dev/null 2>&1; then
                # Skip untracked files if not explicitly desired, though git ls-files should cover tracked files
                continue
            fi

            # Use 'file' command to confirm text content type, avoiding binary files
            if file "$file" | grep -qi "text"; then
              
              # --- Stage 1: Header Removal (Leading ```[lang] or ```) ---
              # Use awk/sed combination for atomic, multi-line replacement safety
              
              # Capture original content hash
              ORIGINAL_HASH=$(sha256sum "$file" | awk '{print $1}')
              
              # 1. Remove leading line if it starts with triple backticks optionally followed by language specifier
              # This handles ```language and ```
              sed -i.bak.header '1{s/^```[A-Za-z0-9_-]*$//; t; s/^```$//}' "$file"
              
              # 2. Remove trailing line if it is exactly triple backticks
              # This handles the closing ``` on its own line
              sed -i.bak.footer '${s/^```$//}' "$file"
              
              # Clean up backup files created by sed if no change occurred (optional, but good practice)
              if [ ! -f "${file}.bak.header" ] && [ ! -f "${file}.bak.footer" ]; then
                  # If sed didn't create backups (because no match), we are fine.
                  :
              fi
              
              # Remove temporary backup files created by sed, regardless of success
              rm -f "${file}.bak.header" "${file}.bak.footer"

              # Capture new content hash
              NEW_HASH=$(sha256sum "$file" 2>/dev/null | awk '{print $1}')
              
              if [[ "$ORIGINAL_HASH" != "$NEW_HASH" ]]; then
                echo "Sanitized: $file"
                # Mark file for staging
                echo "$file" >> /tmp/modified_files.txt
              fi
            fi
          done
          
          if [ -f /tmp/modified_files.txt ]; then
            echo "Sanitization complete. $(wc -l < /tmp/modified_files.txt) files modified."
          else
            echo "Sanitization complete. No modifications detected."
          fi

      - name: Prepare Artifacts and Status Reporting
        run: |
          if [ -f /tmp/modified_files.txt ]; then
            echo "MODIFIED_FILES_LIST=$(cat /tmp/modified_files.txt | tr '\n' ';')" >> $GITHUB_OUTPUT
            echo "CHANGES_DETECTED=true" >> $GITHUB_OUTPUT
          else
            echo "CHANGES_DETECTED=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Conditional Commit and Push Operation (Enterprise Governance Layer)
        if: env.DRY_RUN == 'false' && steps.prepare.outputs.CHANGES_DETECTED == 'true'
        run: |
          echo "Executing governed commit sequence..."
          
          # Add all modified files tracked by the sanitization step
          if [ -f /tmp/modified_files.txt ]; then
            cat /tmp/modified_files.txt | xargs git add
          fi
          
          # Verify changes exist before committing (double check)
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "Committing standardized changes..."
            git commit -m "${{ env.COMMIT_MESSAGE }}"
            
            echo "Pushing changes to ${{ github.ref_name }}..."
            git push origin ${{ github.ref_name }}
            echo "Commit and push successful."
          else
            echo "No changes detected after staging; skipping commit."
          fi

      - name: Final Status Report
        run: |
          echo "--- Codebase Standardization Engine Execution Finished ---"
          if [ "${{ env.DRY_RUN }}" == "true" ]; then
            echo "NOTE: Operation executed in DRY RUN mode. No commits were pushed."
          fi
          if [ "${{ steps.prepare.outputs.CHANGES_DETECTED }}" == "true" ]; then
            echo "Action: Changes were committed and pushed."
          else
            echo "Action: Repository state remains unchanged."
          fi
---